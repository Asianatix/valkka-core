<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Valkka: Frame Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Valkka
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">Massive Video Streaming for Linux</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classFrame-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Frame Class Reference<div class="ingroups"><a class="el" href="group__frames__tag.html">Frames_tag</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A universal frame class encapsulating all media formats.  
 <a href="classFrame.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="frames_8h_source.html">frames.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Frame:</div>
<div class="dyncontent">
<div class="center"><img src="classFrame__coll__graph.png" border="0" usemap="#Frame_coll__map" alt="Collaboration graph"/></div>
<map name="Frame_coll__map" id="Frame_coll__map">
<area shape="rect" id="node2" href="structSetupPars.html" title="SetupPars" alt="" coords="5,5,88,32"/>
<area shape="rect" id="node3" href="structYUVFramePars.html" title="YUVFramePars" alt="" coords="112,5,227,32"/>
<area shape="rect" id="node4" href="classYUVPBO.html" title="Encapsulates OpenGL PBOs (Pixel Buffer Objects) for a YUV420 image. " alt="" coords="251,5,330,32"/>
<area shape="rect" id="node5" href="structAVFramePars.html" title="AVFramePars" alt="" coords="355,5,459,32"/>
<area shape="rect" id="node6" href="structH264Pars.html" title="H264Pars" alt="" coords="483,5,563,32"/>
<area shape="rect" id="node7" href="structPCMUPars.html" title="PCMUPars" alt="" coords="587,5,677,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad2e5946cf41d4817e750500acf05d02b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2e5946cf41d4817e750500acf05d02b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrame.html#ad2e5946cf41d4817e750500acf05d02b">Frame</a> ()</td></tr>
<tr class="memdesc:ad2e5946cf41d4817e750500acf05d02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:ad2e5946cf41d4817e750500acf05d02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec8c7bccdfc88cb4da137caae9f73d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abec8c7bccdfc88cb4da137caae9f73d6"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrame.html#abec8c7bccdfc88cb4da137caae9f73d6">~Frame</a> ()</td></tr>
<tr class="memdesc:abec8c7bccdfc88cb4da137caae9f73d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. <br /></td></tr>
<tr class="separator:abec8c7bccdfc88cb4da137caae9f73d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6de85d60f7f6b1d05cbcb4a98bd245"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc6de85d60f7f6b1d05cbcb4a98bd245"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrame.html#acc6de85d60f7f6b1d05cbcb4a98bd245">reserve</a> (std::size_t n_bytes)</td></tr>
<tr class="memdesc:acc6de85d60f7f6b1d05cbcb4a98bd245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve space for internal payload. <br /></td></tr>
<tr class="separator:acc6de85d60f7f6b1d05cbcb4a98bd245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9eef176e8d433f908afe59fe483c0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb9eef176e8d433f908afe59fe483c0f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrame.html#aeb9eef176e8d433f908afe59fe483c0f">resize</a> (std::size_t n_bytes)</td></tr>
<tr class="memdesc:aeb9eef176e8d433f908afe59fe483c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init space for internal payload. <br /></td></tr>
<tr class="separator:aeb9eef176e8d433f908afe59fe483c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab104eb93ef2212c4c2112f91d340ba50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab104eb93ef2212c4c2112f91d340ba50"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrame.html#ab104eb93ef2212c4c2112f91d340ba50">reset</a> ()</td></tr>
<tr class="memdesc:ab104eb93ef2212c4c2112f91d340ba50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets frame to <a class="el" href="frames_8h.html#ad495a9f61af7fff07d7e97979d1ab854a334c4a4c42fdb79d7ebc3e73b517e6f8" title="Uninitialized frame. ">FrameType::none</a>, nulls <a class="el" href="classFrame.html#a6e31efaba2a5e93fffa7dc07023dad8b" title="This is a pointer to short-lived, temporary storage, used by the FFmpeg decoder (and finally overwrit...">Frame::av_frame</a>, <a class="el" href="classFrame.html#aede3f561f1951d6325aa3fa5bf756627" title="NOT MANAGED by Frame. Managed by a Decoder instance. ">Frame::av_codec_context</a> and <a class="el" href="classFrame.html#a6b86da1e00b483afaf192c75473c055f" title="NOT MANAGED by Frame. Managed by an OpenGLThread instance. ">Frame::yuvpbo</a>. <br /></td></tr>
<tr class="separator:ab104eb93ef2212c4c2112f91d340ba50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e9ae3eac3e0efcb3684723ff77cf34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13e9ae3eac3e0efcb3684723ff77cf34"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrame.html#a13e9ae3eac3e0efcb3684723ff77cf34">dumpPayload</a> ()</td></tr>
<tr class="memdesc:a13e9ae3eac3e0efcb3684723ff77cf34"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns std::string with beginning of the payload <br /></td></tr>
<tr class="separator:a13e9ae3eac3e0efcb3684723ff77cf34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a11ecc89c1ac1e79441dc82feacdc5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62a11ecc89c1ac1e79441dc82feacdc5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrame.html#a62a11ecc89c1ac1e79441dc82feacdc5">dumpAVFrame</a> ()</td></tr>
<tr class="memdesc:a62a11ecc89c1ac1e79441dc82feacdc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns std::string with info about the ffmpeg AVFrame structure <br /></td></tr>
<tr class="separator:a62a11ecc89c1ac1e79441dc82feacdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c39451ae692f3c54ff84a6bdaaaf7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36c39451ae692f3c54ff84a6bdaaaf7d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrame.html#a36c39451ae692f3c54ff84a6bdaaaf7d">fillPars</a> ()</td></tr>
<tr class="memdesc:a36c39451ae692f3c54ff84a6bdaaaf7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspects payload and fills frame parameters (i.e. <a class="el" href="structH264Pars.html">H264Pars</a>, etc.) <br /></td></tr>
<tr class="separator:a36c39451ae692f3c54ff84a6bdaaaf7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d2737d6f4e75f09d168d2761ee42b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96d2737d6f4e75f09d168d2761ee42b7"></a>
long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrame.html#a96d2737d6f4e75f09d168d2761ee42b7">getMsTimestamp</a> ()</td></tr>
<tr class="memdesc:a96d2737d6f4e75f09d168d2761ee42b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the PTS in unix epoch milliseconds. <br /></td></tr>
<tr class="separator:a96d2737d6f4e75f09d168d2761ee42b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1ea5d3a6d5c8d3bfc2481db4ba98f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d1ea5d3a6d5c8d3bfc2481db4ba98f8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrame.html#a4d1ea5d3a6d5c8d3bfc2481db4ba98f8">setMsTimestamp</a> (long int t)</td></tr>
<tr class="memdesc:a4d1ea5d3a6d5c8d3bfc2481db4ba98f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PTS in unix epoch millisecond timestamp. <br /></td></tr>
<tr class="separator:a4d1ea5d3a6d5c8d3bfc2481db4ba98f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596d590b841166a204fe9ba5b9313159"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a596d590b841166a204fe9ba5b9313159"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrame.html#a596d590b841166a204fe9ba5b9313159">copyMeta</a> (<a class="el" href="classFrame.html">Frame</a> *f)</td></tr>
<tr class="memdesc:a596d590b841166a204fe9ba5b9313159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy public metadata across different frame types (timestamp, subsession_index, pars) to f. <br /></td></tr>
<tr class="separator:a596d590b841166a204fe9ba5b9313159"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a6756411f84cc92128275c3785db6d630"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6756411f84cc92128275c3785db6d630"></a>
<a class="el" href="frames_8h.html#ad495a9f61af7fff07d7e97979d1ab854">FrameType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrame.html#a6756411f84cc92128275c3785db6d630">frametype</a></td></tr>
<tr class="memdesc:a6756411f84cc92128275c3785db6d630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the frame. <br /></td></tr>
<tr class="separator:a6756411f84cc92128275c3785db6d630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4505d82fe81505f82dd4924929d8e4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4505d82fe81505f82dd4924929d8e4d"></a>
<a class="el" href="structSetupPars.html">SetupPars</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrame.html#aa4505d82fe81505f82dd4924929d8e4d">setup_pars</a> = {<a class="el" href="frames_8h.html#ad495a9f61af7fff07d7e97979d1ab854a334c4a4c42fdb79d7ebc3e73b517e6f8">FrameType::none</a>}</td></tr>
<tr class="memdesc:aa4505d82fe81505f82dd4924929d8e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used, if frametype == FrameTypes::setup. <br /></td></tr>
<tr class="separator:aa4505d82fe81505f82dd4924929d8e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377a8204065bfddb76547309090e7575"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a377a8204065bfddb76547309090e7575"></a>
<a class="el" href="structH264Pars.html">H264Pars</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrame.html#a377a8204065bfddb76547309090e7575">h264_pars</a> = {H264SliceType::none}</td></tr>
<tr class="memdesc:a377a8204065bfddb76547309090e7575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used, if frametype == FrameTypes::h264. <br /></td></tr>
<tr class="separator:a377a8204065bfddb76547309090e7575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61641fe70c9e7f84e70b8fff626dcbe2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61641fe70c9e7f84e70b8fff626dcbe2"></a>
<a class="el" href="structPCMUPars.html">PCMUPars</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrame.html#a61641fe70c9e7f84e70b8fff626dcbe2">pcmu_pars</a> = {}</td></tr>
<tr class="memdesc:a61641fe70c9e7f84e70b8fff626dcbe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used, if frametype == FrameTypes::pcmu. <br /></td></tr>
<tr class="separator:a61641fe70c9e7f84e70b8fff626dcbe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00bd1ba7888e7f911e2d1e2a48177afd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00bd1ba7888e7f911e2d1e2a48177afd"></a>
<a class="el" href="structAVFramePars.html">AVFramePars</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrame.html#a00bd1ba7888e7f911e2d1e2a48177afd">av_pars</a> = {}</td></tr>
<tr class="memdesc:a00bd1ba7888e7f911e2d1e2a48177afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used, if frametype == FrameTypes::avframe. <br /></td></tr>
<tr class="separator:a00bd1ba7888e7f911e2d1e2a48177afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b341f6ec93fa000615f42caa0fede2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25b341f6ec93fa000615f42caa0fede2"></a>
<a class="el" href="structYUVFramePars.html">YUVFramePars</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrame.html#a25b341f6ec93fa000615f42caa0fede2">yuv_pars</a> = {BitmapPars::notype, AV_PIX_FMT_NONE}</td></tr>
<tr class="memdesc:a25b341f6ec93fa000615f42caa0fede2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used, if frametype == FrameTypes::yuvframe. <br /></td></tr>
<tr class="separator:a25b341f6ec93fa000615f42caa0fede2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6de613c5c8bb6b383dc108cef6c415f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6de613c5c8bb6b383dc108cef6c415f"></a>
long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrame.html#ae6de613c5c8bb6b383dc108cef6c415f">mstimestamp</a></td></tr>
<tr class="memdesc:ae6de613c5c8bb6b383dc108cef6c415f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Presentation time stamp (PTS) in milliseconds. <br /></td></tr>
<tr class="separator:ae6de613c5c8bb6b383dc108cef6c415f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf128935ea3e7966af10e9bd08df785"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aadf128935ea3e7966af10e9bd08df785"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrame.html#aadf128935ea3e7966af10e9bd08df785">subsession_index</a></td></tr>
<tr class="memdesc:aadf128935ea3e7966af10e9bd08df785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Media subsession index. <br /></td></tr>
<tr class="separator:aadf128935ea3e7966af10e9bd08df785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afceac675e9e36fdf011aaa605d78c3d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afceac675e9e36fdf011aaa605d78c3d9"></a>
SlotNumber&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrame.html#afceac675e9e36fdf011aaa605d78c3d9">n_slot</a></td></tr>
<tr class="memdesc:afceac675e9e36fdf011aaa605d78c3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slot number identifying the media source. <br /></td></tr>
<tr class="separator:afceac675e9e36fdf011aaa605d78c3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b131179e6402e7af5e75cd0cc0044a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93b131179e6402e7af5e75cd0cc0044a"></a>
std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrame.html#a93b131179e6402e7af5e75cd0cc0044a">payload</a></td></tr>
<tr class="memdesc:a93b131179e6402e7af5e75cd0cc0044a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw payload data (use .data() to get the pointer from std::vector) <br /></td></tr>
<tr class="separator:a93b131179e6402e7af5e75cd0cc0044a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e31efaba2a5e93fffa7dc07023dad8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e31efaba2a5e93fffa7dc07023dad8b"></a>
AVFrame *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrame.html#a6e31efaba2a5e93fffa7dc07023dad8b">av_frame</a></td></tr>
<tr class="memdesc:a6e31efaba2a5e93fffa7dc07023dad8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a pointer to short-lived, temporary storage, used by the FFmpeg decoder (and finally overwritten by it). The idea is, that the data is copied from here asap, to *_pars structure and to payload. Just a pointer. NOT MANAGED by <a class="el" href="classFrame.html" title="A universal frame class encapsulating all media formats. ">Frame</a>. Managed by a <a class="el" href="classDecoder.html" title="Decoder using FFmpeg/libav. ">Decoder</a> instance,. <br /></td></tr>
<tr class="separator:a6e31efaba2a5e93fffa7dc07023dad8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede3f561f1951d6325aa3fa5bf756627"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aede3f561f1951d6325aa3fa5bf756627"></a>
AVCodecContext *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrame.html#aede3f561f1951d6325aa3fa5bf756627">av_codec_context</a></td></tr>
<tr class="memdesc:aede3f561f1951d6325aa3fa5bf756627"><td class="mdescLeft">&#160;</td><td class="mdescRight">NOT MANAGED by <a class="el" href="classFrame.html" title="A universal frame class encapsulating all media formats. ">Frame</a>. Managed by a <a class="el" href="classDecoder.html" title="Decoder using FFmpeg/libav. ">Decoder</a> instance. <br /></td></tr>
<tr class="separator:aede3f561f1951d6325aa3fa5bf756627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b86da1e00b483afaf192c75473c055f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b86da1e00b483afaf192c75473c055f"></a>
<a class="el" href="classYUVPBO.html">YUVPBO</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrame.html#a6b86da1e00b483afaf192c75473c055f">yuvpbo</a></td></tr>
<tr class="memdesc:a6b86da1e00b483afaf192c75473c055f"><td class="mdescLeft">&#160;</td><td class="mdescRight">NOT MANAGED by <a class="el" href="classFrame.html" title="A universal frame class encapsulating all media formats. ">Frame</a>. Managed by an <a class="el" href="classOpenGLThread.html" title="This class does a lot of things: ">OpenGLThread</a> instance. <br /></td></tr>
<tr class="separator:a6b86da1e00b483afaf192c75473c055f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6f41b23d499abc051668f17c5ef37440"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f41b23d499abc051668f17c5ef37440"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, <a class="el" href="classFrame.html">Frame</a> const &amp;m)</td></tr>
<tr class="separator:a6f41b23d499abc051668f17c5ef37440"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A universal frame class encapsulating all media formats. </p>
<p>So, why not define a base frame class and then subclassing for each media type, i.e. <a class="el" href="classFrame.html" title="A universal frame class encapsulating all media formats. ">Frame</a> =&gt; H264Frame, PCMUFrame, .. and for decoded: YUV420Frame, etc. where H264Frame and YUV420Frame would have different methods, say H264Frame for peeking the frame type (intra frame, sps, pps, etc.), and YUV420Frame methods for extracting luma, chroma, etc.</p>
<p>In the multithreading fifos we want to reserve the frame objects beforehand. This way we avoid constant memory (de)allocations. However, not knowing what frames to expect, we can only instantiate the base class <a class="el" href="classFrame.html" title="A universal frame class encapsulating all media formats. ">Frame</a>.</p>
<p>This class is a bit like ffmpeg's AVPacket structure. Another possibility would be to use AVPackets only, but that's not flexible enough for our needs.</p>
<p>Creating a deep copy of a <a class="el" href="classFrame.html" title="A universal frame class encapsulating all media formats. ">Frame</a> instance (including a copy of the payload):</p>
<div class="fragment"><div class="line"><a class="code" href="classFrame.html">Frame</a> *f1;</div><div class="line"><a class="code" href="classFrame.html">Frame</a> *f2</div><div class="line"></div><div class="line">f1=<span class="keyword">new</span> <a class="code" href="classFrame.html#ad2e5946cf41d4817e750500acf05d02b">Frame</a>();</div><div class="line">f2=<span class="keyword">new</span> <a class="code" href="classFrame.html#ad2e5946cf41d4817e750500acf05d02b">Frame</a>();</div><div class="line"></div><div class="line">*(f1) = *(f2)</div></div><!-- fragment --><p>I.e. it can be done directly with the "=" operator. The underlying vector smart pointer takes care of payload copying and resizing the payload in the target frame.</p>
<p>If the target frame is a frame owned by a fifo queue, then the payload in that frame will also grow in order to fit the payload. This way fifos will adapt automagically to the needed payload size.</p>
<p>Payload data is found for encoded data typically from the <a class="el" href="classFrame.html#a93b131179e6402e7af5e75cd0cc0044a" title="Raw payload data (use .data() to get the pointer from std::vector) ">Frame::payload</a> bytebuffer. Depending on <a class="el" href="classFrame.html#a6756411f84cc92128275c3785db6d630" title="Type of the frame. ">Frame::frametype</a>, it can also be found from <a class="el" href="classFrame.html#a6e31efaba2a5e93fffa7dc07023dad8b" title="This is a pointer to short-lived, temporary storage, used by the FFmpeg decoder (and finally overwrit...">Frame::av_frame</a> or <a class="el" href="classFrame.html#a6b86da1e00b483afaf192c75473c055f" title="NOT MANAGED by Frame. Managed by an OpenGLThread instance. ">Frame::yuvpbo</a>. <a class="el" href="classFrame.html#a6e31efaba2a5e93fffa7dc07023dad8b" title="This is a pointer to short-lived, temporary storage, used by the FFmpeg decoder (and finally overwrit...">Frame::av_frame</a> and <a class="el" href="classFrame.html#a6b86da1e00b483afaf192c75473c055f" title="NOT MANAGED by Frame. Managed by an OpenGLThread instance. ">Frame::yuvpbo</a> are not managed (allocated/freed) from <a class="el" href="classFrame.html" title="A universal frame class encapsulating all media formats. ">Frame</a>. </p>
</div><hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/sampsa/C/valkka/include/<a class="el" href="frames_8h_source.html">frames.h</a></li>
<li>/home/sampsa/C/valkka/src/<a class="el" href="frames_8cpp.html">frames.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
